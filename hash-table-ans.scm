;; The goal is to have a hash fn that is quick to compute
;; and evenly distributes  strings into buckets
;; The way we do that is by taking modulo hashed size
;; essentially compressing down
;; so what's the problem with something like string
;;""Why is it called a hash? Because the key is usually generated by mashing all the bits of the data together to make as random a mess as possible"

;; What happens if we use a bad hash fn?
(define (make-hash hash eql? oops size)
  (let ((table (make-vector size '())))
    (lambda (message . args)
      (if (eq? message 'enlist)
          (let loop ((k 0) (result '()))
            (if (= size k)
                result
                (loop (+ k 1) (append (vector-ref table k) result))))
          (let* ((key (car args))
                 (index (modulo (hash key) size))
                 (bucket (vector-ref table index)))
            (case message
              ((lookup)
               (let loop ((bucket bucket))
                 (cond ((null? bucket) oops)
                       ((eql? (caar bucket) key) (cdar bucket))
                       (else (loop (cdr bucket))))))
              ((insert)
               (vector-set! table index
                (let loop ((bucket bucket))
                  (cond ((null? bucket)
                         (list (cons key (cadr args))))
                        ((eql? (caar bucket) key)
                         (cons (cons key (cadr args)) (cdr bucket)))
                        (else (cons (car bucket) (loop (cdr bucket))))))))
              ((delete)
               (vector-set! table index
                (let loop ((bucket bucket))
                  (cond ((null? bucket) '())
                        ((eql? (caar bucket) key)
                         (cdr bucket))
                        (else (cons (car bucket) (loop (cdr bucket))))))))
              ((update)
               (vector-set! table index
                (let loop ((bucket bucket))
                  (cond ((null? bucket)
                         (list (cons key (caddr args))))
                        ((eql? (caar bucket) key)
                         (cons (cons key ((cadr args) key (cdar bucket)))
                               (cdr bucket)))
                        (else (cons (car bucket) (loop (cdr bucket))))))))
              (else (error 'hash-table "unrecognizable message"))))))))

;; I don't understand why 31.
;; Let's take an example
;; f=102
;; o=111
;; so foo is: ((102*31 + 111) * 31) + 111 = 101574.
;; why is that a good thing? we are essentially shifting by
;; 5, almost.
;; how diff vs djb2?
;; hash(fo) = hash(f) * 33 ^
;; "The value 31 was chosen because it is an odd prime. If it were even and the multiplication overflowed, information would be lost, as multiplication by 2 is equivalent to shifting. The advantage of using a prime is less clear, but it is traditional."
;; If even, shifting left would remove info and just introduce zero.
;; Also, for 31 all words up to 6 letters have unique hash codes.
;; Using something like 9 would create laps
;; Can we show this?
;; "Because you want the number you are multiplying by and the number of buckets you are inserting into to have orthogonal prime factorizations."
;; "Suppose there are 8 buckets to insert into. If the number you are using to multiply by is some multiple of 8, then the bucket inserted into will only be determined by the least significant entry (the one not multiplied at all). Similar entries will collide. Not good for a hash function."
;; This seems relevant
(define (string-hash str)
  (let loop ((cs (string->list str)) (s 0))
    (if (null? cs) s
        (loop (cdr cs) (+ (* s 31)
                          (char->integer (car cs)))))))
